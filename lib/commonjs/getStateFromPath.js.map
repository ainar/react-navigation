{"version":3,"sources":["getStateFromPath.tsx"],"names":["getStateFromPath","path","options","undefined","initialRoutes","configs","concat","Object","keys","map","key","createNormalizedConfigs","result","current","remaining","replace","routeNames","params","config","match","paramPatterns","pattern","split","filter","p","startsWith","length","reduce","acc","i","value","parse","segments","decodeURIComponent","shift","join","state","routeName","initialRoute","findInitialRoute","createNestedState","nestedState","routes","index","query","route","queryString","parseFunction","findParseConfigForRoute","name","forEach","routeConfig","initials","push","createConfigItem","screens","initialRouteName","connectedRoutes","nestedConfig","pop","RegExp","flatConfig","includes","isEmpty"],"mappings":"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","sourcesContent":["import escape from 'escape-string-regexp';\r\nimport queryString from 'query-string';\r\nimport {\r\n  NavigationState,\r\n  PartialState,\r\n  InitialState,\r\n} from '@react-navigation/routers';\r\n\r\ntype ParseConfig = Record<string, (value: string) => any>;\r\n\r\ntype Options = {\r\n  [routeName: string]:\r\n    | string\r\n    | {\r\n        path?: string;\r\n        parse?: ParseConfig;\r\n        screens?: Options;\r\n        initialRouteName?: string;\r\n      };\r\n};\r\n\r\ntype RouteConfig = {\r\n  match: RegExp;\r\n  pattern: string;\r\n  routeNames: string[];\r\n  parse: ParseConfig | undefined;\r\n};\r\n\r\ntype InitialRouteConfig = {\r\n  initialRouteName: string;\r\n  connectedRoutes: string[];\r\n};\r\n\r\ntype ResultState = PartialState<NavigationState> & {\r\n  state?: ResultState;\r\n};\r\n\r\n/**\r\n * Utility to parse a path string to initial state object accepted by the container.\r\n * This is useful for deep linking when we need to handle the incoming URL.\r\n *\r\n * Example:\r\n * ```js\r\n * getStateFromPath(\r\n *   '/chat/jane/42',\r\n *   {\r\n *     Chat: {\r\n *       path: 'chat/:author/:id',\r\n *       parse: { id: Number }\r\n *     }\r\n *   }\r\n * )\r\n * ```\r\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\r\n * @param options Extra options to fine-tune how to parse the path.\r\n */\r\nexport default function getStateFromPath(\r\n  path: string,\r\n  options: Options = {}\r\n): ResultState | undefined {\r\n  if (path === '') {\r\n    return undefined;\r\n  }\r\n  let initialRoutes: InitialRouteConfig[] = [];\r\n  // Create a normalized configs array which will be easier to use\r\n  const configs = ([] as RouteConfig[]).concat(\r\n    ...Object.keys(options).map((key) =>\r\n      createNormalizedConfigs(key, options, [], initialRoutes)\r\n    )\r\n  );\r\n\r\n  let result: PartialState<NavigationState> | undefined;\r\n  let current: PartialState<NavigationState> | undefined;\r\n\r\n  let remaining = path\r\n    .replace(/[/]+/, '/') // Replace multiple slash (//) with single ones\r\n    .replace(/^\\//, '') // Remove extra leading slash\r\n    .replace(/\\?.*/, ''); // Remove query params which we will handle later\r\n\r\n  while (remaining) {\r\n    let routeNames: string[] | undefined;\r\n    let params: Record<string, any> | undefined;\r\n\r\n    // Go through all configs, and see if the next path segment matches our regex\r\n    for (const config of configs) {\r\n      const match = remaining.match(config.match);\r\n\r\n      // If our regex matches, we need to extract params from the path\r\n      if (match) {\r\n        routeNames = [...config.routeNames];\r\n\r\n        const paramPatterns = config.pattern\r\n          .split('/')\r\n          .filter((p) => p.startsWith(':'));\r\n\r\n        if (paramPatterns.length) {\r\n          params = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\r\n            const key = p.replace(/^:/, '');\r\n            const value = match[i + 1]; // The param segments start from index 1 in the regex match result\r\n\r\n            acc[key] =\r\n              config.parse && config.parse[key]\r\n                ? config.parse[key](value)\r\n                : value;\r\n\r\n            return acc;\r\n          }, {});\r\n        }\r\n\r\n        // Remove the matched segment from the remaining path\r\n        remaining = remaining.replace(match[0], '');\r\n\r\n        break;\r\n      }\r\n    }\r\n\r\n    // If we hadn't matched any segments earlier, use the path as route name\r\n    if (routeNames === undefined) {\r\n      const segments = remaining.split('/');\r\n\r\n      routeNames = [decodeURIComponent(segments[0])];\r\n      segments.shift();\r\n      remaining = segments.join('/');\r\n    }\r\n\r\n    let state: InitialState;\r\n    let routeName = routeNames.shift() as string;\r\n    let initialRoute = findInitialRoute(routeName, initialRoutes);\r\n\r\n    state = createNestedState(\r\n      initialRoute,\r\n      routeName,\r\n      routeNames.length === 0,\r\n      params\r\n    );\r\n\r\n    if (routeNames.length > 0) {\r\n      let nestedState = state;\r\n\r\n      while ((routeName = routeNames.shift() as string)) {\r\n        initialRoute = findInitialRoute(routeName, initialRoutes);\r\n        nestedState.routes[nestedState.index || 0].state = createNestedState(\r\n          initialRoute,\r\n          routeName,\r\n          routeNames.length === 0,\r\n          params\r\n        );\r\n        if (routeNames.length > 0) {\r\n          nestedState = nestedState.routes[nestedState.index || 0]\r\n            .state as InitialState;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (current) {\r\n      // The state should be nested inside the deepest route we parsed before\r\n      while (current?.routes[current.index || 0].state) {\r\n        current = current.routes[current.index || 0].state;\r\n      }\r\n\r\n      (current as PartialState<NavigationState>).routes[\r\n        current?.index || 0\r\n      ].state = state;\r\n    } else {\r\n      result = state;\r\n    }\r\n\r\n    current = state;\r\n  }\r\n\r\n  if (current == null || result == null) {\r\n    return undefined;\r\n  }\r\n\r\n  const query = path.split('?')[1];\r\n\r\n  if (query) {\r\n    while (current?.routes[current.index || 0].state) {\r\n      // The query params apply to the deepest route\r\n      current = current.routes[current.index || 0].state;\r\n    }\r\n\r\n    const route = (current as PartialState<NavigationState>).routes[\r\n      current?.index || 0\r\n    ];\r\n\r\n    const params = queryString.parse(query);\r\n    const parseFunction = findParseConfigForRoute(route.name, configs);\r\n\r\n    if (parseFunction) {\r\n      Object.keys(params).forEach((name) => {\r\n        if (parseFunction[name] && typeof params[name] === 'string') {\r\n          params[name] = parseFunction[name](params[name] as string);\r\n        }\r\n      });\r\n    }\r\n\r\n    route.params = { ...route.params, ...params };\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction createNormalizedConfigs(\r\n  key: string,\r\n  routeConfig: Options,\r\n  routeNames: string[] = [],\r\n  initials: InitialRouteConfig[]\r\n): RouteConfig[] {\r\n  const configs: RouteConfig[] = [];\r\n\r\n  routeNames.push(key);\r\n\r\n  const value = routeConfig[key];\r\n\r\n  if (typeof value === 'string') {\r\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\r\n    if (value !== '') {\r\n      configs.push(createConfigItem(routeNames, value));\r\n    }\r\n  } else if (typeof value === 'object') {\r\n    // if an object is specified as the value (e.g. Foo: { ... }),\r\n    // it can have `path` property and\r\n    // it could have `screens` prop which has nested configs\r\n    if (value.path && value.path !== '') {\r\n      configs.push(createConfigItem(routeNames, value.path, value.parse));\r\n    }\r\n    if (value.screens) {\r\n      // property `initialRouteName` without `screens` has no purpose\r\n      if (value.initialRouteName) {\r\n        initials.push({\r\n          initialRouteName: value.initialRouteName,\r\n          connectedRoutes: Object.keys(value.screens),\r\n        });\r\n      }\r\n      Object.keys(value.screens).forEach((nestedConfig) => {\r\n        const result = createNormalizedConfigs(\r\n          nestedConfig,\r\n          value.screens as Options,\r\n          routeNames,\r\n          initials\r\n        );\r\n        configs.push(...result);\r\n      });\r\n    }\r\n  }\r\n\r\n  routeNames.pop();\r\n\r\n  return configs;\r\n}\r\n\r\nfunction createConfigItem(\r\n  routeNames: string[],\r\n  pattern: string,\r\n  parse?: ParseConfig\r\n): RouteConfig {\r\n  const match = new RegExp(\r\n    '^' + escape(pattern).replace(/:[a-z0-9]+/gi, '([^/]+)') + '/?'\r\n  );\r\n\r\n  return {\r\n    match,\r\n    pattern,\r\n    // The routeNames array is mutated, so copy it to keep the current state\r\n    routeNames: [...routeNames],\r\n    parse,\r\n  };\r\n}\r\n\r\nfunction findParseConfigForRoute(\r\n  routeName: string,\r\n  flatConfig: RouteConfig[]\r\n): ParseConfig | undefined {\r\n  for (const config of flatConfig) {\r\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\r\n      return config.parse;\r\n    }\r\n  }\r\n  return undefined;\r\n}\r\n\r\n// tries to find an initial route connected with the one passed\r\nfunction findInitialRoute(\r\n  routeName: string,\r\n  initialRoutes: InitialRouteConfig[]\r\n): string | undefined {\r\n  for (const config of initialRoutes) {\r\n    if (config.connectedRoutes.includes(routeName)) {\r\n      return config.initialRouteName === routeName\r\n        ? undefined\r\n        : config.initialRouteName;\r\n    }\r\n  }\r\n  return undefined;\r\n}\r\n\r\n// returns nested state object with values depending on whether\r\n// it is the end of state and if there is initialRoute for this level\r\nfunction createNestedState(\r\n  initialRoute: string | undefined,\r\n  routeName: string,\r\n  isEmpty: boolean,\r\n  params?: Record<string, any> | undefined\r\n): InitialState {\r\n  if (isEmpty) {\r\n    if (initialRoute) {\r\n      return {\r\n        index: 1,\r\n        routes: [\r\n          { name: initialRoute },\r\n          { name: routeName as string, ...(params && { params }) },\r\n        ],\r\n      };\r\n    } else {\r\n      return {\r\n        routes: [{ name: routeName as string, ...(params && { params }) }],\r\n      };\r\n    }\r\n  } else {\r\n    if (initialRoute) {\r\n      return {\r\n        index: 1,\r\n        routes: [\r\n          { name: initialRoute },\r\n          { name: routeName as string, state: { routes: [] } },\r\n        ],\r\n      };\r\n    } else {\r\n      return { routes: [{ name: routeName as string, state: { routes: [] } }] };\r\n    }\r\n  }\r\n}\r\n"]}